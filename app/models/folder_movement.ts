import { DateTime } from 'luxon'
import {
  BaseModel,
  beforeCreate,
  belongsTo,
  column,
  scope,
  SnakeCaseNamingStrategy,
} from '@adonisjs/lucid/orm'
import type { BelongsTo } from '@adonisjs/lucid/types/relations'
import type { ModelQueryBuilderContract } from '@adonisjs/lucid/types/model'
import Folder from '#models/folder'
import User from '#models/user'

type FolderMovementBuilder = ModelQueryBuilderContract<typeof FolderMovement>

export default class FolderMovement extends BaseModel {
  static table = 'folder_movements'
  static namingStrategy = new SnakeCaseNamingStrategy()

  /**
   * ------------------------------------------------------
   * Columns
   * ------------------------------------------------------
   */
  @column({ isPrimary: true })
  declare id: number

  @column()
  declare folderId: number

  @column()
  declare movementType: string

  @column()
  declare title: string

  @column()
  declare description: string

  @column()
  declare fullText: string | null

  @column()
  declare courtProtocol: string | null

  @column()
  declare responsibleParty: string | null

  @column.dateTime()
  declare movementDate: DateTime

  @column.dateTime()
  declare registeredDate: DateTime | null

  @column()
  declare source: string

  @column()
  declare requiresAction: boolean

  @column()
  declare isDeadline: boolean

  @column.date()
  declare deadlineDate: DateTime | null

  @column()
  declare urgencyLevel: string

  @column()
  declare notified: boolean

  @column()
  declare tags: string[] | null

  @column()
  declare category: string | null

  @column()
  declare isFavorable: boolean | null

  @column()
  declare changesStatus: boolean

  @column()
  declare externalData: Record<string, any> | null

  @column()
  declare externalId: string | null

  @column()
  declare autoGenerated: boolean

  @column()
  declare automationMetadata: Record<string, any> | null

  @column()
  declare attachedDocuments: string[] | null

  @column()
  declare createdById: number | null

  @column()
  declare updatedById: number | null

  @column()
  declare isPublic: boolean

  @column()
  declare internalNotes: string | null

  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  /**
   * ------------------------------------------------------
   * Relationships
   * ------------------------------------------------------
   */
  @belongsTo(() => Folder, {
    foreignKey: 'folderId',
  })
  declare folder: BelongsTo<typeof Folder>

  @belongsTo(() => User, {
    foreignKey: 'createdById',
  })
  declare createdBy: BelongsTo<typeof User>

  @belongsTo(() => User, {
    foreignKey: 'updatedById',
  })
  declare updatedBy: BelongsTo<typeof User>

  /**
   * ------------------------------------------------------
   * Hooks
   * ------------------------------------------------------
   */
  @beforeCreate()
  static async setDefaultValues(movement: FolderMovement) {
    if (!movement.source) {
      movement.source = 'manual'
    }

    if (movement.requiresAction === undefined || movement.requiresAction === null) {
      movement.requiresAction = false
    }

    if (movement.isDeadline === undefined || movement.isDeadline === null) {
      movement.isDeadline = false
    }

    if (!movement.urgencyLevel) {
      movement.urgencyLevel = 'normal'
    }

    if (movement.notified === undefined || movement.notified === null) {
      movement.notified = false
    }

    if (movement.changesStatus === undefined || movement.changesStatus === null) {
      movement.changesStatus = false
    }

    if (movement.autoGenerated === undefined || movement.autoGenerated === null) {
      movement.autoGenerated = false
    }

    if (movement.isPublic === undefined || movement.isPublic === null) {
      movement.isPublic = true
    }

    if (!movement.movementDate) {
      movement.movementDate = DateTime.now()
    }
  }

  /**
   * ------------------------------------------------------
   * Query Scopes
   * ------------------------------------------------------
   */
  static byFolder = scope((query: FolderMovementBuilder, folderId: number) => {
    query.where('folder_id', folderId)
  })

  static byType = scope((query: FolderMovementBuilder, type: string) => {
    query.where('movement_type', type)
  })

  static requiresAction = scope((query: FolderMovementBuilder) => {
    query.where('requires_action', true)
  })

  static withDeadlines = scope((query: FolderMovementBuilder) => {
    query.where('is_deadline', true).whereNotNull('deadline_date')
  })

  static upcomingDeadlines = scope((query: FolderMovementBuilder, days: number = 30) => {
    const futureDate = DateTime.now().plus({ days }).toSQLDate()
    query
      .where('is_deadline', true)
      .whereBetween('deadline_date', [DateTime.now().toSQLDate(), futureDate])
  })

  static byUrgency = scope((query: FolderMovementBuilder, level: string) => {
    query.where('urgency_level', level)
  })

  static urgent = scope((query: FolderMovementBuilder) => {
    query.whereIn('urgency_level', ['high', 'urgent'])
  })

  static favorable = scope((query: FolderMovementBuilder) => {
    query.where('is_favorable', true)
  })

  static unfavorable = scope((query: FolderMovementBuilder) => {
    query.where('is_favorable', false)
  })

  static automated = scope((query: FolderMovementBuilder) => {
    query.where('auto_generated', true)
  })

  static manual = scope((query: FolderMovementBuilder) => {
    query.where('auto_generated', false)
  })

  static publicMovements = scope((query: FolderMovementBuilder) => {
    query.where('is_public', true)
  })

  static recent = scope((query: FolderMovementBuilder, days: number = 30) => {
    const pastDate = DateTime.now().minus({ days })
    query.where('movement_date', '>=', pastDate.toSQL())
  })

  static search = scope((query: FolderMovementBuilder, searchTerm: string) => {
    query.where((q) => {
      q.whereILike('title', `%${searchTerm}%`)
        .orWhereILike('description', `%${searchTerm}%`)
        .orWhereILike('full_text', `%${searchTerm}%`)
        .orWhereILike('court_protocol', `%${searchTerm}%`)
        .orWhereILike('responsible_party', `%${searchTerm}%`)
    })
  })

  static withRelationships = scope((query: FolderMovementBuilder) => {
    query.preload('folder').preload('createdBy')
  })

  /**
   * ------------------------------------------------------
   * Computed Properties
   * ------------------------------------------------------
   */
  public get displayTitle(): string {
    return this.title
  }

  public get isOverdue(): boolean {
    if (!this.isDeadline || !this.deadlineDate) return false
    return DateTime.fromJSDate(this.deadlineDate) < DateTime.now()
  }

  public get daysUntilDeadline(): number | null {
    if (!this.isDeadline || !this.deadlineDate) return null
    const deadlineDate = DateTime.fromJSDate(this.deadlineDate)
    return Math.ceil(deadlineDate.diff(DateTime.now(), 'days').days)
  }

  public get isUrgent(): boolean {
    return ['high', 'urgent'].includes(this.urgencyLevel)
  }

  public get statusColor(): string {
    if (this.isOverdue) return '#EF4444' // red
    if (this.isUrgent) return '#F59E0B' // amber
    if (this.isFavorable === true) return '#10B981' // green
    if (this.isFavorable === false) return '#EF4444' // red
    return '#6B7280' // gray
  }

  public get ageInDays(): number {
    return Math.floor(DateTime.now().diff(this.movementDate, 'days').days)
  }

  public get hasAttachments(): boolean {
    return !!(this.attachedDocuments && this.attachedDocuments.length > 0)
  }

  public get isExternal(): boolean {
    return ['court_api', 'loy_system'].includes(this.source)
  }
}
